import os
import json
import logging
from .database import Finding, Patch, Evidence
from .sandbox import SandboxService
from .llm import LLMService


class VulnerabilityProcessor:
    def __init__(self, db_session, llm_service: LLMService, sandbox_service: SandboxService, vcs_service, google_web_search):
        self.db_session = db_session
        self.llm_service = llm_service
        self.sandbox_service = sandbox_service
        self.vcs_service = vcs_service
        self.google_web_search = google_web_search

    def process_vulnerability(self, vulnerability, local_path, repo_url, scan, auto_patch=False):
        if not self.validate_vulnerability_with_search(vulnerability):
            return

        logging.info(f"\n+++ Potential Vulnerability Found: {vulnerability['description']} +++")
        
        file_path = vulnerability.get('file_path')
        if not file_path:
            pass
        elif local_path in file_path:
            file_path = os.path.relpath(file_path, local_path)

        if file_path:
            full_path = os.path.join(local_path, file_path)
            if not os.path.exists(full_path):
                logging.warning(f"Skipping finding, file not found: {full_path}")
                return

            line_number = vulnerability.get('line_number')
            if line_number:
                try:
                    with open(full_path, 'r', errors='ignore') as f:
                        lines = f.readlines()
                    if line_number > len(lines):
                        logging.warning(f"Skipping finding, line number {line_number} is out of bounds for file {full_path} which has {len(lines)} lines.")
                        return
                except Exception as e:
                    logging.error(f"Could not read file {full_path} to verify line count: {e}")
        
        logging.info(f"File: {file_path}, Line: {vulnerability['line_number']}")

        if vulnerability.get('code_snippet') == 'requires login':
            try:
                with open(full_path, 'r', errors='ignore') as f:
                    lines = f.readlines()
                line_number = vulnerability.get('line_number')
                start = max(0, line_number - 4)
                end = min(len(lines), line_number + 3)
                vulnerability['code_snippet'] = "".join(lines[start:end])
            except Exception as e:
                logging.error(f"Could not read file {full_path} to extract code snippet: {e}")

        finding = Finding(
            scan_id=scan.id,
            file_path=file_path,
            line_number=vulnerability.get('line_number'),
            code_snippet=vulnerability.get('code_snippet'),
            description=vulnerability.get('description'),
            severity=self._map_severity(vulnerability.get('severity', 'UNKNOWN')),
        )
        self.db_session.add(finding)
        self.db_session.commit()

        analysis = self.llm_service.get_root_cause_analysis(
            vulnerability['code_snippet'], vulnerability['description']
        )
        logging.info("\n--- Root Cause Analysis ---")
        logging.info(analysis)

        evidence_analysis = Evidence(finding_id=finding.id, type='root_cause_analysis', content=analysis)
        self.db_session.add(evidence_analysis)
        self.db_session.commit()

        if not scan.generate_test_script:
            logging.info("\n--- Skipping test script generation as per scan settings ---")
            if auto_patch:
                logging.info("\nGenerating patch without test script verification...")
                patch_diff = self.llm_service.generate_patch(vulnerability['code_snippet'], analysis)
                logging.info("\n--- Generated Patch ---")
                logging.info(patch_diff)

                if patch_diff:
                    patch = Patch(finding_id=finding.id, generated_patch_diff=patch_diff)
                    self.db_session.add(patch)
                    self.db_session.commit()

                    self.vcs_service.create_pull_request(
                        repo_path=local_path,
                        repo_url=repo_url,
                        branch_name=f'v-raptor-fix/{os.path.basename(vulnerability["file_path"]).replace(".","_")}-{vulnerability["line_number"]}',
                        title=f'Fix: {vulnerability["description"]}',
                        body=f"### V-Raptor Analysis\n\n**Vulnerability:** {vulnerability['description']}\n\n**File:** `{vulnerability['file_path']}`\n\n**Line:** {vulnerability['line_number']}\n\n**Root Cause Analysis:**\n{analysis}\n\nThis patch was automatically generated by V-Raptor.",
                        patch_diff=patch_diff
                    )
                else:
                    logging.info("Patch generation failed or returned empty.")
            return

        test_script = self.llm_service.generate_test_script(
            vulnerability['code_snippet'], vulnerability['description']
        )
        logging.info("\n--- Generated Test Script ---")
        logging.info(test_script)

        evidence_test_script = Evidence(finding_id=finding.id, type='test_script', content=test_script)
        self.db_session.add(evidence_test_script)
        self.db_session.commit()

        container_id = self.sandbox_service.create_sandbox()
        if not container_id:
            return

        try:
            output = self.sandbox_service.execute_python_script(container_id, test_script)
            logging.info("\n--- Test Script Output ---")
            logging.info(output)

            evidence_test_output = Evidence(finding_id=finding.id, type='test_output', content=output)
            self.db_session.add(evidence_test_output)
            self.db_session.commit()

            confidence_score = self.llm_service.interpret_results(analysis, test_script, output)
            logging.info(f"\nConfidence Score: {confidence_score}")
            finding.confidence_score = confidence_score
            self.db_session.commit()


            if auto_patch and confidence_score > 0.7:
                logging.info("\nHigh confidence score. Generating patch...")
                patch_diff = self.llm_service.generate_patch(vulnerability['code_snippet'], analysis)
                logging.info("\n--- Generated Patch ---")
                logging.info(patch_diff)

                if patch_diff:
                    patch = Patch(finding_id=finding.id, generated_patch_diff=patch_diff)
                    self.db_session.add(patch)
                    self.db_session.commit()

                    self.vcs_service.create_pull_request(
                        repo_path=local_path,
                        repo_url=repo_url,
                        branch_name=f'v-raptor-fix/{os.path.basename(vulnerability["file_path"]).replace(".","_")}-{vulnerability["line_number"]}',
                        title=f'Fix: {vulnerability["description"]}',
                        body=f"### V-Raptor Analysis\n\n**Vulnerability:** {vulnerability['description']}\n\n**File:** `{vulnerability['file_path']}`\n\n**Line:** {vulnerability['line_number']}\n\n**Root Cause Analysis:**\n{analysis}\n\nThis patch was automatically generated by V-Raptor based on a confidence score of {confidence_score:.2f}.",
                        patch_diff=patch_diff
                    )
                else:
                    logging.info("Patch generation failed or returned empty.")
            else:
                logging.info("Confidence score is too low or auto_patch is disabled, skipping patch generation.")
        finally:
            self.sandbox_service.destroy_sandbox(container_id)

    def validate_vulnerability_with_search(self, vulnerability):
        """Validates a vulnerability by searching for it on the web."""
        if not self.google_web_search:
            logging.info("--- Web search validation skipped: search function not provided. ---")
            return True
        logging.info(f"\n--- Validating Vulnerability: {vulnerability['description']} ---")
        search_query = f"{vulnerability['description']} {vulnerability['code_snippet']}"
        search_results = self.google_web_search(query=search_query)

        if not search_results:
            return True # If search fails, proceed with the vulnerability

        response_text = self.llm_service.validate_vulnerability(vulnerability['description'], search_results)
        try:
            data = json.loads(response_text)
            if data.get("false_positive"):
                logging.info("Vulnerability identified as a false positive.")
                return False
        except json.JSONDecodeError:
            logging.info("Error: Could not decode LLM response as JSON.")
        
        return True

    def rewrite_remediation(self, finding_id):
        """Re-writes a remediation for a finding."""
        finding = self.db_session.query(Finding).get(finding_id)
        if not finding:
            return

        analysis_evidence = self.db_session.query(Evidence).filter_by(finding_id=finding.id, type='root_cause_analysis').first()
        analysis = analysis_evidence.content if analysis_evidence else ''

        patch_diff = self.llm_service.generate_patch(finding.code_snippet, analysis)
        logging.info("\n--- Generated Patch ---")
        logging.info(patch_diff)

        if patch_diff:
            patch = self.db_session.query(Patch).filter_by(finding_id=finding.id).first()
            if not patch:
                patch = Patch(finding_id=finding.id)
                self.db_session.add(patch)
            patch.generated_patch_diff = patch_diff
            self.db_session.commit()

    def recheck_finding(self, finding_id):
        """Re-checks a finding by re-running the test script."""
        finding = self.db_session.query(Finding).get(finding_id)
        if not finding:
            return

        test_script_evidence = self.db_session.query(Evidence).filter_by(finding_id=finding.id, type='test_script').first()
        if not test_script_evidence:
            return

        container_id = self.sandbox_service.create_sandbox()
        if not container_id:
            return

        try:
            output = self.sandbox_service.execute_python_script(container_id, test_script_evidence.content)
            logging.info("\n--- Test Script Output ---")
            logging.info(output)

            evidence_test_output = self.db_session.query(Evidence).filter_by(finding_id=finding.id, type='test_output').first()
            if not evidence_test_output:
                evidence_test_output = Evidence(finding_id=finding.id, type='test_output')
                self.db_session.add(evidence_test_output)
            evidence_test_output.content = output
            self.db_session.commit()

            analysis_evidence = self.db_session.query(Evidence).filter_by(finding_id=finding.id, type='root_cause_analysis').first()
            analysis = analysis_evidence.content if analysis_evidence else ''

            confidence_score = self.llm_service.interpret_results(analysis, test_script_evidence.content, output)
            logging.info(f"\nConfidence Score: {confidence_score}")
            finding.confidence_score = confidence_score
            self.db_session.commit()
        finally:
            self.sandbox_service.destroy_sandbox(container_id)

    def process_dependency_vulnerability(self, vulnerability, scan):
        logging.info(f"\n+++ Potential Dependency Vulnerability Found: {vulnerability['description']} +++")

        finding = Finding(
            scan_id=scan.id,
            description=vulnerability['description'],
            severity=vulnerability.get('severity', 'UNKNOWN'),
            cve_id=vulnerability['cve_id'],
        )
        self.db_session.add(finding)
        self.db_session.commit()

        analysis = self.llm_service.get_root_cause_analysis(
            '', vulnerability['description']
        )
        logging.info("\n--- Root Cause Analysis ---")
        logging.info(analysis)

        evidence_analysis = Evidence(finding_id=finding.id, type='root_cause_analysis', content=analysis)
        self.db_session.add(evidence_analysis)
        self.db_session.commit()

    def process_config_vulnerability(self, vulnerability, scan):
        logging.info(f"\n+++ Potential Config Vulnerability Found: {vulnerability['description']} +++")

        finding = Finding(
            scan_id=scan.id,
            file_path=vulnerability['file_path'],
            line_number=vulnerability['line_number'],
            description=vulnerability['description'],
        )
        self.db_session.add(finding)
        self.db_session.commit()

        analysis = self.llm_service.get_root_cause_analysis(
            '', vulnerability['description']
        )
        logging.info("\n--- Root Cause Analysis ---")
        logging.info(analysis)

        evidence_analysis = Evidence(finding_id=finding.id, type='root_cause_analysis', content=analysis)
        self.db_session.add(evidence_analysis)
        self.db_session.commit()

    def _map_severity(self, severity):
        """Maps severity from tools to a standardized format."""
        logging.info(f"Mapping severity: {severity}")
        sev_upper = severity.upper()
        if sev_upper in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']:
            logging.info(f"Mapped to: {sev_upper}")
            return sev_upper
        if sev_upper == 'ERROR':
            logging.info("Mapped to: HIGH")
            return 'HIGH'
        if sev_upper == 'WARNING':
            logging.info("Mapped to: MEDIUM")
            return 'MEDIUM'
        if sev_upper == 'INFO':
            logging.info("Mapped to: LOW")
            return 'LOW'
        logging.info("Mapped to: UNKNOWN")
        return 'UNKNOWN'
