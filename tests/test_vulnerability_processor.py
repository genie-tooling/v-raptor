import unittest
from unittest.mock import patch, MagicMock
from src.vulnerability_processor import VulnerabilityProcessor
from src.database import Finding, Patch, Evidence, Scan

class TestVulnerabilityProcessor(unittest.TestCase):

    def setUp(self):
        self.db_session = MagicMock()
        self.llm_service = MagicMock()
        self.sandbox_service = MagicMock()
        self.vcs_service = MagicMock()
        self.google_web_search = MagicMock()
        self.vulnerability_processor = VulnerabilityProcessor(
            self.db_session,
            self.llm_service,
            self.sandbox_service,
            self.vcs_service,
            self.google_web_search
        )

    @patch('os.path.exists')
    @patch('builtins.open')
    def test_process_vulnerability_auto_patch_false(self, mock_open, mock_exists):
        """Test that a vulnerability is processed correctly when auto_patch is False."""
        mock_exists.return_value = True
        mock_open.return_value.__enter__.return_value.readlines.return_value = ['line1', 'line2']
        self.google_web_search.return_value = 'some search results'
        self.llm_service.validate_vulnerability.return_value = '{"false_positive": false}'

        vulnerability = {
            'file_path': '/fake/path/test.py',
            'line_number': 1,
            'description': 'test vulnerability',
            'code_snippet': 'test code',
            'severity': 'high'
        }
        scan = Scan(id=1, generate_test_script=False)
        
        self.vulnerability_processor.process_vulnerability(vulnerability, '/fake/path', 'http://fake.url', scan, auto_patch=False)

        self.db_session.add.assert_called()
        self.db_session.commit.assert_called()
        self.llm_service.get_root_cause_analysis.assert_called_once()

    @patch('os.path.exists')
    @patch('builtins.open')
    def test_process_vulnerability_auto_patch_true(self, mock_open, mock_exists):
        """Test that a vulnerability is processed correctly when auto_patch is True."""
        mock_exists.return_value = True
        mock_open.return_value.__enter__.return_value.readlines.return_value = ['line1', 'line2']
        self.google_web_search.return_value = 'some search results'
        self.llm_service.validate_vulnerability.return_value = '{"false_positive": false}'
        self.llm_service.generate_patch.return_value = 'test patch'

        vulnerability = {
            'file_path': '/fake/path/test.py',
            'line_number': 1,
            'description': 'test vulnerability',
            'code_snippet': 'test code',
            'severity': 'high'
        }
        scan = Scan(id=1, generate_test_script=False)

        self.vulnerability_processor.process_vulnerability(vulnerability, '/fake/path', 'http://fake.url', scan, auto_patch=True)

        self.db_session.add.assert_called()
        self.db_session.commit.assert_called()
        self.llm_service.get_root_cause_analysis.assert_called_once()
        self.llm_service.generate_patch.assert_called_once()
        self.vcs_service.create_pull_request.assert_called_once()

    def test_process_vulnerability_false_positive(self):
        """Test that a vulnerability is not processed if it's identified as a false positive."""
        self.google_web_search.return_value = 'some search results'
        self.llm_service.validate_vulnerability.return_value = '{"false_positive": true}'

        vulnerability = {
            'file_path': '/fake/path/test.py',
            'line_number': 1,
            'description': 'test vulnerability',
            'code_snippet': 'test code',
            'severity': 'high'
        }
        scan = Scan(id=1, generate_test_script=False)

        self.vulnerability_processor.process_vulnerability(vulnerability, '/fake/path', 'http://fake.url', scan, auto_patch=False)

        self.db_session.add.assert_not_called()

    @patch('os.path.exists')
    def test_process_vulnerability_file_not_found(self, mock_exists):
        """Test that a vulnerability is not processed if the file is not found."""
        mock_exists.return_value = False
        self.google_web_search.return_value = 'some search results'
        self.llm_service.validate_vulnerability.return_value = '{"false_positive": false}'

        vulnerability = {
            'file_path': '/fake/path/test.py',
            'line_number': 1,
            'description': 'test vulnerability',
            'code_snippet': 'test code',
            'severity': 'high'
        }
        scan = Scan(id=1, generate_test_script=False)

        self.vulnerability_processor.process_vulnerability(vulnerability, '/fake/path', 'http://fake.url', scan, auto_patch=False)

        self.db_session.add.assert_not_called()

    def test_validate_vulnerability_with_search(self):
        """Test that a vulnerability is validated correctly."""
        self.google_web_search.return_value = 'some search results'
        self.llm_service.validate_vulnerability.return_value = '{"false_positive": false}'
        vulnerability = {
            'description': 'test vulnerability',
            'code_snippet': 'test code'
        }
        result = self.vulnerability_processor.validate_vulnerability_with_search(vulnerability)
        self.assertTrue(result)

    def test_map_severity(self):
        """Test that severities are mapped correctly."""
        self.assertEqual(self.vulnerability_processor._map_severity('CRITICAL'), 'CRITICAL')
        self.assertEqual(self.vulnerability_processor._map_severity('High'), 'HIGH')
        self.assertEqual(self.vulnerability_processor._map_severity('medium'), 'MEDIUM')
        self.assertEqual(self.vulnerability_processor._map_severity('low'), 'LOW')
        self.assertEqual(self.vulnerability_processor._map_severity('error'), 'HIGH')
        self.assertEqual(self.vulnerability_processor._map_severity('warning'), 'MEDIUM')
        self.assertEqual(self.vulnerability_processor._map_severity('info'), 'LOW')
        self.assertEqual(self.vulnerability_processor._map_severity('unknown'), 'UNKNOWN')

    @patch('os.path.exists')
    @patch('builtins.open')
    def test_process_vulnerability_with_test_script(self, mock_open, mock_exists):
        """Test that a vulnerability is processed correctly with test script generation."""
        mock_exists.return_value = True
        mock_open.return_value.__enter__.return_value.readlines.return_value = ['line1', 'line2']
        self.google_web_search.return_value = 'some search results'
        self.llm_service.validate_vulnerability.return_value = '{"false_positive": false}'
        self.llm_service.generate_test_script.return_value = 'test script'
        self.sandbox_service.create_sandbox.return_value = 'test-container-id'
        self.sandbox_service.execute_python_script.return_value = 'test output'
        self.llm_service.interpret_results.return_value = 0.9

        vulnerability = {
            'file_path': '/fake/path/test.py',
            'line_number': 1,
            'description': 'test vulnerability',
            'code_snippet': 'test code',
            'severity': 'high'
        }
        scan = Scan(id=1, generate_test_script=True)

        self.vulnerability_processor.process_vulnerability(vulnerability, '/fake/path', 'http://fake.url', scan, auto_patch=False)

        self.db_session.add.assert_called()
        self.db_session.commit.assert_called()
        self.llm_service.get_root_cause_analysis.assert_called_once()
        self.llm_service.generate_test_script.assert_called_once()
        self.sandbox_service.create_sandbox.assert_called_once()
        self.sandbox_service.execute_python_script.assert_called_once_with('test-container-id', 'test script')
        self.llm_service.interpret_results.assert_called_once()
        self.sandbox_service.destroy_sandbox.assert_called_once_with('test-container-id')

    def test_recheck_finding(self):
        """Test that a finding is rechecked correctly."""
        finding = Finding(id=1)
        test_script_evidence = Evidence(content='test script')
        self.db_session.query.return_value.get.return_value = finding
        self.db_session.query.return_value.filter_by.return_value.first.return_value = test_script_evidence
        self.sandbox_service.create_sandbox.return_value = 'test-container-id'
        self.sandbox_service.execute_python_script.return_value = 'test output'

        self.vulnerability_processor.recheck_finding(1)

        self.sandbox_service.create_sandbox.assert_called_once()
        self.sandbox_service.execute_python_script.assert_called_once_with('test-container-id', 'test script')
        self.sandbox_service.destroy_sandbox.assert_called_once_with('test-container-id')
        self.llm_service.interpret_results.assert_called_once()
        self.db_session.commit.assert_called()

    def test_rewrite_remediation(self):
        """Test that a remediation is rewritten correctly."""
        finding = Finding(id=1, code_snippet='test code')
        analysis_evidence = Evidence(content='test analysis')
        self.db_session.query.return_value.get.return_value = finding
        self.db_session.query.return_value.filter_by.return_value.first.return_value = analysis_evidence
        self.llm_service.generate_patch.return_value = 'test patch'

        self.vulnerability_processor.rewrite_remediation(1)

        self.llm_service.generate_patch.assert_called_once_with('test code', 'test analysis')
        self.db_session.commit.assert_called()


if __name__ == '__main__':
    unittest.main()
